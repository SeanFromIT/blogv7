---
author: SeanFromIT
comments: "true"
date: 2008-12-19 01:01:00+00:00
layout: post
link: https://feeney.mba/2008/12/19/the-future-of-software-engineering/
slug: the-future-of-software-engineering
title: The Future of Software Engineering
wordpress_id: 176
categories:
- Adobe
- data portability
- Good Business Practices
- google
- Microsoft
- open source
- rose-hulman
- software engineering
- Web Apps
- web development
---

Update 8/11/17: A pretty good article came out describing the difference between CS and SE, and you should read it: [Don't Confuse Computer Science with Software Engineering](https://code.berlin/en/blog/computer-science-software-engineering/)

Despite IEEE efforts, there is industry confusion over what a software engineer (SE) is and what a programmer or computer scientist (CS) is. As it is taught at Rose-Hulman, the nation’s top undergraduate engineering college, software engineering is “the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software.” It’s a broad field, and as such individual software engineers often specialize in some subset of the process. For example, I specialize in web engineering or “[web science](http://www.webscience.org/) .”

Computer science on the other hand often puts its graduates into the role of the programmer – a code monkey who relishes in the design of elegant algorithms. According to [Wikipedia](http://en.wikipedia.org/wiki/Computer_science) , computer science is “the study and the science of the theoretical foundations of information and computation and their implementation and application in computer systems.” In practice, an SE could be doing CS work and vice versa, but as taught at Rose-Hulman the SE has additional knowledge in project management and the entire software life cycle. An SE major usually chooses the SE path because he or she isn’t all that interested in the cut-and-dry coding part of the life cycle.

The two fields are rapidly moving apart, in part driven by the outsourcing of code monkey work. Outside of boutique software shops, software engineers are expected to focus on the initial and latter steps of the life cycle while managing others doing everything in between. Will the future bring more abstraction from coding for software engineers?

I think so. I’m not talking about abstraction from code – as technical managers, software engineers will always be knee deep in code – but from the actual coding itself. Case in point: open sourceology. Once just a morally good idea, I’ve seen many technologists self-describing themselves as open sourceologists these days. The benefits of open source are plentiful and self-obvious, and now we have people marketing themselves as being capable of choosing, integrating, and deploying customized open source solutions (myself included). Less than 5% of systems built today are completely new - see the A7 NRL Project. Some industry experts I’ve spoken to envision the future for software engineers being practically nothing but picking and choosing already written components to build a completely new system, ready-customized for the domain at hand. Others still like Shawn Bohner, Rose-Hulman’s new Director of Software Engineering, picture a world where software will write itself.

Another future, one which Google, Microsoft, Adobe and others are banking on, is web applications and cloud computing. A world in which the accessing/input device used by the customer doesn’t matter, data can be securely accessed from anywhere, and desktop applications seamlessly integrate with web counterparts. Note that this future does not necessarily include [data portability](http://www.dataportability.org/) , but let’s hope it does. The software engineer in this world is best served by creativity and strong UI and communication skills, as customers can come and go as they please without needing to consult their IT department.

Any shop that doesn’t value web skills over traditional application skills – and yes, there is a difference - is doomed to fail in the second case, and any shop that continues to write everything from scratch will fall behind and/or fail in the first case. My advice to companies that want to survive into the next decade is to hire based on overall competencies in areas that are set to matter the most – creativity, UI, cross-compatibility, language independence, platform scaling, customer interaction and testing – and consider traditional skills “a plus.” Coding as an art can be beautiful, but it’s not what the customer sees and won’t pay the bills. Companies are catching on that there are already existing solutions available that mostly cover their needs and simply need a little tweaking for their individual requirements – I wouldn’t expect them to pay you to continually reinvent the wheel for too much longer.
